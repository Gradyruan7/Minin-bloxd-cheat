    // src/items/inventory.js
    var inventoryCleanerInterval = null;
    var inventoryWrapper2 = null;

    function setInventoryWrapper(wrapper) {
        inventoryWrapper2 = wrapper;
    }

    function cleanInventory() {
        if (!inventoryWrapper2 || !inventoryWrapper2.playerInventory || !inventoryWrapper2.playerInventory.items)
            return;
        const inv = inventoryWrapper2.playerInventory;
        if (inv) {
            let getMaterialRankForItem = function(item) {
                    if (!item || !item.name)
                        return -1;
                    const mat = Object.keys(materialRank).find((m) => item.name.includes(m));
                    return mat ? materialRank[mat] : -1;
                },
                findIndices = function(predicate) {
                    const result = [];
                    for (let i = 0; i <= 45; i++) {
                        const it = items[i];
                        if (it && predicate(it, i))
                            result.push(i);
                    }
                    return result;
                };
            const items = inv.items;
            const isHotbarIndex = (idx) => idx >= 0 && idx <= 9;
            const isInventoryIndex = (idx) => idx >= 10 && idx <= 45;
            const materialRank = {
                "Wood": 0,
                "Stone": 1,
                "Iron": 2,
                "Gold": 3,
                "Diamond": 4,
                "Knight": 5
            };
            const dropNames = ["Seeds", "Sapling", "Mushroom", "Empty Bottle"];
            for (let i = 0; i <= 45; i++) {
                const item = items[i];
                if (!item)
                    continue;
                if (dropNames.some((name) => item.name.includes(name))) {
                    inventoryWrapper2.removeItemClient(i, item.amount, true);
                }
            }
            const armorTypes = {
                "Helmet": 46,
                "Chestplate": 47,
                "Gauntlets": 48,
                "Leggings": 49,
                "Boots": 50
            };
            for (let i = 0; i <= 45; i++) {
                const item = items[i];
                if (!item)
                    continue;
                const type = Object.keys(armorTypes).find((t) => item.name.includes(t));
                if (!type)
                    continue;
                const material = Object.keys(materialRank).find((m) => item.name.includes(m));
                if (!material)
                    continue;
                const targetSlot = armorTypes[type];
                const currentArmorItem = items[targetSlot];
                if (!currentArmorItem) {
                    inventoryWrapper2.swapPosClient(i, targetSlot);
                } else {
                    const currentMat = Object.keys(materialRank).find((m) => currentArmorItem.name.includes(m));
                    const currentRank = currentMat ? materialRank[currentMat] : -1;
                    if (materialRank[material] > currentRank) {
                        inventoryWrapper2.swapPosClient(i, targetSlot);
                    } else {
                        inventoryWrapper2.removeItemClient(i, 1, true);
                    }
                }
            }
            const swordIndices = findIndices((it) => it.name.includes("Sword"));
            let bestSwordIdx = -1;
            let bestSwordRank = -1;
            for (const idx of swordIndices) {
                const rank = getMaterialRankForItem(items[idx]);
                if (rank > bestSwordRank) {
                    bestSwordRank = rank;
                    bestSwordIdx = idx;
                }
            }
            if (bestSwordIdx !== -1) {
                const hot0 = items[0];
                if (!hot0) {
                    if (bestSwordIdx !== 0)
                        inventoryWrapper2.swapPosClient(bestSwordIdx, 0);
                } else {
                    if (hot0.name.includes("Sword")) {
                        const hot0Rank = getMaterialRankForItem(hot0);
                        if (bestSwordRank > hot0Rank) {
                            inventoryWrapper2.swapPosClient(bestSwordIdx, 0);
                            bestSwordIdx = 0;
                        }
                    } else {
                        inventoryWrapper2.swapPosClient(bestSwordIdx, 0);
                        bestSwordIdx = 0;
                    }
                }
            }
            for (const idx of swordIndices) {
                if (idx === bestSwordIdx)
                    continue;
                const it = items[idx];
                if (!it || !it.name.includes("Sword"))
                    continue;
                inventoryWrapper2.removeItemClient(idx, 1, true);
            }
            const bowIndices = findIndices((it) => it.name.includes("Bow"));
            let bestBowIdx = -1;
            let bestBowRank = -1;
            for (const idx of bowIndices) {
                const rank = getMaterialRankForItem(items[idx]);
                if (rank > bestBowRank) {
                    bestBowRank = rank;
                    bestBowIdx = idx;
                }
            }
            if (bestBowIdx !== -1) {
                const hot1 = items[1];
                if (!hot1) {
                    if (bestBowIdx !== 1)
                        inventoryWrapper2.swapPosClient(bestBowIdx, 1);
                } else {
                    if (hot1.name.includes("Bow")) {
                        const hot1Rank = getMaterialRankForItem(hot1);
                        if (bestBowRank > hot1Rank) {
                            inventoryWrapper2.swapPosClient(bestBowIdx, 1);
                            bestBowIdx = 1;
                        }
                    } else {
                        inventoryWrapper2.swapPosClient(bestBowIdx, 1);
                        bestBowIdx = 1;
                    }
                }
            }
            for (const idx of bowIndices) {
                if (idx === bestBowIdx)
                    continue;
                const it = items[idx];
                if (!it || !it.name.includes("Bow"))
                    continue;
                inventoryWrapper2.removeItemClient(idx, 1, true);
            }
            for (let h = 0; h <= 9; h++) {
                const hotItem = items[h];
                if (!hotItem)
                    continue;
                if (hotItem.name.includes("Arrow")) {
                    let freeSlot = -1;
                    for (let s = 10; s <= 45; s++) {
                        if (!items[s]) {
                            freeSlot = s;
                            break;
                        }
                    }
                    if (freeSlot !== -1) {
                        inventoryWrapper2.swapPosClient(h, freeSlot);
                    }
                }
            }
            const pickIndices = findIndices((it) => it.name.includes("Pickaxe"));
            let bestPickIdx = -1;
            let bestPickRank = -1;
            for (const idx of pickIndices) {
                const rank = getMaterialRankForItem(items[idx]);
                if (rank > bestPickRank) {
                    bestPickRank = rank;
                    bestPickIdx = idx;
                }
            }
            if (bestPickIdx !== -1) {
                const hot2 = items[2];
                if (!hot2) {
                    if (bestPickIdx !== 2)
                        inventoryWrapper2.swapPosClient(bestPickIdx, 2);
                } else {
                    if (hot2.name.includes("Pickaxe")) {
                        const hot2Rank = getMaterialRankForItem(hot2);
                        if (bestPickRank > hot2Rank) {
                            inventoryWrapper2.swapPosClient(bestPickIdx, 2);
                            bestPickIdx = 2;
                        }
                    } else {
                        inventoryWrapper2.swapPosClient(bestPickIdx, 2);
                        bestPickIdx = 2;
                    }
                }
            }
            for (const idx of pickIndices) {
                if (idx === bestPickIdx)
                    continue;
                const it = items[idx];
                if (!it || !it.name.includes("Pickaxe"))
                    continue;
                inventoryWrapper2.removeItemClient(idx, 1, true);
            }
            const blockNames = ["Wood Planks", "Messy Stone"];
            for (const name of blockNames) {
                const indices = findIndices((it) => it.name.includes(name) && it.typeObj && it.typeObj.stackable);
                if (indices.length <= 1)
                    continue;
                let target = indices[0];
                for (let k = 1; k < indices.length; k++) {
                    const src = indices[k];
                    const srcItem = items[src];
                    if (!srcItem)
                        continue;
                    try {
                        inventoryWrapper2.moveItemIntoIdxsClient(target, target + 1, src, srcItem.amount);
                    } catch (e) {
                        inventoryWrapper2.swapPosClient(src, target);
                    }
                }
            }
            let bestBlockSlot = -1;
            let bestBlockAmount = -1;
            for (let i = 0; i <= 45; i++) {
                const it = items[i];
                if (!it)
                    continue;
                if (blockNames.some((name) => it.name.includes(name))) {
                    if (it.amount > bestBlockAmount && it.amount !== bestBlockAmount) {
                        bestBlockAmount = it.amount;
                        bestBlockSlot = i;
                    }
                }
            }
            if (bestBlockSlot !== -1) {
                const hot9 = items[9];
                if (!hot9) {
                    if (bestBlockSlot !== 9)
                        inventoryWrapper2.swapPosClient(bestBlockSlot, 9);
                } else {
                    inventoryWrapper2.swapPosClient(bestBlockSlot, 9);
                }
            } {
                const snowIndices = findIndices((it) => it.name.includes("Snowball") && it.typeObj && it.typeObj.stackable);
                if (snowIndices.length > 0) {
                    const target = snowIndices[0];
                    for (let k = 1; k < snowIndices.length; k++) {
                        const src = snowIndices[k];
                        if (!items[src])
                            continue;
                        try {
                            inventoryWrapper2.moveItemIntoIdxsClient(target, target + 1, src, items[src].amount);
                        } catch (e) {
                            inventoryWrapper2.swapPosClient(src, target);
                        }
                    }
                    const hot3 = items[3];
                    if (!hot3) {
                        if (target !== 3)
                            inventoryWrapper2.swapPosClient(target, 3);
                    } else {
                        inventoryWrapper2.swapPosClient(target, 3);
                    }
                }
            } {
                const breadIndices = findIndices((it) => it.name.includes("Bread") && it.typeObj && it.typeObj.stackable);
                if (breadIndices.length > 0) {
                    const target = breadIndices[0];
                    for (let k = 1; k < breadIndices.length; k++) {
                        const src = breadIndices[k];
                        if (!items[src])
                            continue;
                        try {
                            inventoryWrapper2.moveItemIntoIdxsClient(target, target + 1, src, items[src].amount);
                        } catch (e) {
                            inventoryWrapper2.swapPosClient(src, target);
                        }
                    }
                    const hot8 = items[8];
                    if (!hot8) {
                        if (target !== 8)
                            inventoryWrapper2.swapPosClient(target, 8);
                    } else {
                        inventoryWrapper2.swapPosClient(target, 8);
                    }
                }
            } {
                const potionIndices = findIndices((it) => it.name.includes("Shield Potion") && it.typeObj);
                if (potionIndices.length > 0) {
                    const target = potionIndices[0];
                    const hot7 = items[7];
                    if (!hot7 || !hot7.name.includes("Shield Potion")) {
                        inventoryWrapper2.swapPosClient(target, 7);
                    }
                }
            }
        }
    }

    function sortInventory() {
        if (!inventoryWrapper2 || !inventoryWrapper2.playerInventory?.items)
            return false;
        const items = inventoryWrapper2.playerInventory.items;
        let swapped;
        do {
            swapped = false;
            for (let idx = 10; idx < 45; idx++) {
                const item1 = items[idx];
                const item2 = items[idx + 1];
                if (!item1 && item2 || item1 && item2 && item1.name > item2.name) {
                    inventoryWrapper2.swapPosClient(idx, idx + 1);
                    swapped = true;
                }
            }
        } while (swapped);
        return true;
    }

    function startInventoryCleaner() {
        if (!inventoryCleanerInterval) {
            inventoryCleanerInterval = setInterval(cleanInventory, 50);
        }
    }

    function stopInventoryCleaner() {
        if (inventoryCleanerInterval) {
            clearInterval(inventoryCleanerInterval);
            inventoryCleanerInterval = null;
        }
    }
